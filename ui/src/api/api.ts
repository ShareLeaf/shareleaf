/* tslint:disable */
/* eslint-disable */
/**
 * Resume Repo API
 * REST API for Resume Repo backend services
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface RRCVByKeyRequest
 */
export interface RRCVByKeyRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RRCVByKeyRequest
     */
    object_keys: Array<string>;
}
/**
 * 
 * @export
 * @interface RRCVDataResponse
 */
export interface RRCVDataResponse {
    /**
     * 
     * @type {string}
     * @memberof RRCVDataResponse
     */
    cv_key?: string;
    /**
     * 
     * @type {RRCVTemplate}
     * @memberof RRCVDataResponse
     */
    template_type?: RRCVTemplate;
    /**
     * 
     * @type {RRResume}
     * @memberof RRCVDataResponse
     */
    resume?: RRResume;
    /**
     * 
     * @type {RRResume}
     * @memberof RRCVDataResponse
     */
    cover_letter?: RRResume;
}
/**
 * 
 * @export
 * @interface RRCVKey
 */
export interface RRCVKey {
    /**
     * 
     * @type {string}
     * @memberof RRCVKey
     */
    object_key: string;
}
/**
 * 
 * @export
 * @interface RRCVMetadata
 */
export interface RRCVMetadata {
    /**
     * 
     * @type {string}
     * @memberof RRCVMetadata
     */
    cv_key: string;
    /**
     * 
     * @type {RRObjectType}
     * @memberof RRCVMetadata
     */
    cv_type: RRObjectType;
    /**
     * 
     * @type {string}
     * @memberof RRCVMetadata
     */
    cv_title: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRCVMetadata
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof RRCVMetadata
     */
    read_only: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RRCVMetadata
     */
    is_deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RRCVMetadata
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof RRCVMetadata
     */
    updated_at: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof RRCVMetadata
     */
    children: Array<object> | null;
    /**
     * 
     * @type {boolean}
     * @memberof RRCVMetadata
     */
    is_default_profile: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RRCVMetadata
     */
    is_public: boolean;
    /**
     * 
     * @type {string}
     * @memberof RRCVMetadata
     */
    public_url?: string;
    /**
     * 
     * @type {RRCVTemplate}
     * @memberof RRCVMetadata
     */
    template_name: RRCVTemplate;
}
/**
 * 
 * @export
 * @interface RRCVMetadataResponse
 */
export interface RRCVMetadataResponse {
    /**
     * 
     * @type {Array<RRCVMetadata>}
     * @memberof RRCVMetadataResponse
     */
    records: Array<RRCVMetadata>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RRCVTemplate {
    PROFESSIONAL = 'professional',
    MODERN = 'modern',
    CLASSIC = 'classic'
}

/**
 * 
 * @export
 * @interface RRCopyResponse
 */
export interface RRCopyResponse {
    /**
     * 
     * @type {RRObjectMetadata}
     * @memberof RRCopyResponse
     */
    object_metadata: RRObjectMetadata;
}
/**
 * 
 * @export
 * @interface RRCreateFromTemplateRequest
 */
export interface RRCreateFromTemplateRequest {
    /**
     * 
     * @type {RRCVTemplate}
     * @memberof RRCreateFromTemplateRequest
     */
    template_name: RRCVTemplate;
}
/**
 * 
 * @export
 * @interface RRCreateObjectRequest
 */
export interface RRCreateObjectRequest {
    /**
     * 
     * @type {string}
     * @memberof RRCreateObjectRequest
     */
    object_name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRCreateObjectRequest
     */
    tags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RRCreateObjectRequest
     */
    content: string;
    /**
     * 
     * @type {RRObjectType}
     * @memberof RRCreateObjectRequest
     */
    object_type: RRObjectType;
}
/**
 * 
 * @export
 * @interface RRDiffResponse
 */
export interface RRDiffResponse {
    /**
     * 
     * @type {string}
     * @memberof RRDiffResponse
     */
    content_1: string;
    /**
     * 
     * @type {string}
     * @memberof RRDiffResponse
     */
    content_2: string;
}
/**
 * 
 * @export
 * @interface RREducation
 */
export interface RREducation {
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    institution?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    location?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    major?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    minor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RREducation
     */
    gpa?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RREducation
     */
    is_current?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RREducation
     */
    items?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    start_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RREducation
     */
    end_date?: string | null;
}
/**
 * 
 * @export
 * @interface RRExtracurricular
 */
export interface RRExtracurricular {
    /**
     * 
     * @type {string}
     * @memberof RRExtracurricular
     */
    position?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRExtracurricular
     */
    institution?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRExtracurricular
     */
    location?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RRExtracurricular
     */
    is_current?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRExtracurricular
     */
    items?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RRExtracurricular
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRExtracurricular
     */
    start_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRExtracurricular
     */
    end_date?: string | null;
}
/**
 * 
 * @export
 * @interface RRGenericResponse
 */
export interface RRGenericResponse {
    /**
     * 
     * @type {string}
     * @memberof RRGenericResponse
     */
    status?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRGenericResponse
     */
    error?: string | null;
}
/**
 * 
 * @export
 * @interface RRKeyResponse
 */
export interface RRKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof RRKeyResponse
     */
    object_key: string;
}
/**
 * 
 * @export
 * @interface RRObjectByKeyRequest
 */
export interface RRObjectByKeyRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RRObjectByKeyRequest
     */
    object_keys: Array<string>;
}
/**
 * 
 * @export
 * @interface RRObjectDataResponse
 */
export interface RRObjectDataResponse {
    /**
     * 
     * @type {string}
     * @memberof RRObjectDataResponse
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof RRObjectDataResponse
     */
    object_key: string;
}
/**
 * 
 * @export
 * @interface RRObjectDiffRequest
 */
export interface RRObjectDiffRequest {
    /**
     * 
     * @type {string}
     * @memberof RRObjectDiffRequest
     */
    source_id: string;
    /**
     * 
     * @type {string}
     * @memberof RRObjectDiffRequest
     */
    target_id: string;
}
/**
 * 
 * @export
 * @interface RRObjectMetadata
 */
export interface RRObjectMetadata {
    /**
     * 
     * @type {string}
     * @memberof RRObjectMetadata
     */
    object_key: string;
    /**
     * 
     * @type {RRObjectType}
     * @memberof RRObjectMetadata
     */
    object_type: RRObjectType;
    /**
     * 
     * @type {string}
     * @memberof RRObjectMetadata
     */
    object_name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRObjectMetadata
     */
    tags: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RRObjectMetadata
     */
    read_only: boolean;
    /**
     * 
     * @type {string}
     * @memberof RRObjectMetadata
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof RRObjectMetadata
     */
    updated_at: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof RRObjectMetadata
     */
    children: Array<object>;
}
/**
 * 
 * @export
 * @interface RRObjectMetadataResponse
 */
export interface RRObjectMetadataResponse {
    /**
     * 
     * @type {Array<RRObjectMetadata>}
     * @memberof RRObjectMetadataResponse
     */
    records: Array<RRObjectMetadata>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RRObjectType {
    TYPE_R = 'resume',
    TYPE_CL = 'cover_letter'
}

/**
 * 
 * @export
 * @interface RRPaginatedCVResponse
 */
export interface RRPaginatedCVResponse {
    /**
     * 
     * @type {number}
     * @memberof RRPaginatedCVResponse
     */
    total_records: number;
    /**
     * 
     * @type {number}
     * @memberof RRPaginatedCVResponse
     */
    num_pages: number;
    /**
     * 
     * @type {Array<RRCVMetadata>}
     * @memberof RRPaginatedCVResponse
     */
    records: Array<RRCVMetadata>;
}
/**
 * 
 * @export
 * @interface RRPaginatedRequest
 */
export interface RRPaginatedRequest {
    /**
     * 
     * @type {number}
     * @memberof RRPaginatedRequest
     */
    limit: number;
    /**
     * 
     * @type {number}
     * @memberof RRPaginatedRequest
     */
    next_page_num: number;
    /**
     * 
     * @type {Array<RRSortColumns>}
     * @memberof RRPaginatedRequest
     */
    sort_by?: Array<RRSortColumns>;
    /**
     * 
     * @type {Array<RRSortDirection>}
     * @memberof RRPaginatedRequest
     */
    sort_dir?: Array<RRSortDirection>;
    /**
     * 
     * @type {RRObjectType}
     * @memberof RRPaginatedRequest
     */
    object_type: RRObjectType;
    /**
     * 
     * @type {string}
     * @memberof RRPaginatedRequest
     */
    query?: string;
}
/**
 * 
 * @export
 * @interface RRPaginatedResponse
 */
export interface RRPaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof RRPaginatedResponse
     */
    total_records: number;
    /**
     * 
     * @type {number}
     * @memberof RRPaginatedResponse
     */
    num_pages: number;
    /**
     * 
     * @type {Array<RRObjectMetadata>}
     * @memberof RRPaginatedResponse
     */
    records: Array<RRObjectMetadata>;
}
/**
 * 
 * @export
 * @interface RRProject
 */
export interface RRProject {
    /**
     * 
     * @type {string}
     * @memberof RRProject
     */
    title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRProject
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RRProject
     */
    is_current?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRProject
     */
    items?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RRProject
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRProject
     */
    start_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRProject
     */
    end_date?: string | null;
}
/**
 * 
 * @export
 * @interface RRResume
 */
export interface RRResume {
    /**
     * 
     * @type {string}
     * @memberof RRResume
     */
    cv_key?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RRResume
     */
    is_default_profile: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RRResume
     */
    read_only: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RRResume
     */
    is_public: boolean;
    /**
     * 
     * @type {string}
     * @memberof RRResume
     */
    cv_title: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRResume
     */
    tags?: Array<string> | null;
    /**
     * 
     * @type {RRObjectType}
     * @memberof RRResume
     */
    cv_type: RRObjectType;
    /**
     * 
     * @type {RRUserProfile}
     * @memberof RRResume
     */
    profile?: RRUserProfile;
    /**
     * 
     * @type {Array<RREducation>}
     * @memberof RRResume
     */
    education?: Array<RREducation>;
    /**
     * 
     * @type {Array<RRWorkExperience>}
     * @memberof RRResume
     */
    work_experience?: Array<RRWorkExperience>;
    /**
     * 
     * @type {Array<RRExtracurricular>}
     * @memberof RRResume
     */
    extracurriculars?: Array<RRExtracurricular>;
    /**
     * 
     * @type {Array<RRProject>}
     * @memberof RRResume
     */
    projects?: Array<RRProject>;
    /**
     * 
     * @type {Array<RRSkills>}
     * @memberof RRResume
     */
    skills?: Array<RRSkills>;
    /**
     * 
     * @type {Array<RRSocial>}
     * @memberof RRResume
     */
    socials?: Array<RRSocial>;
}
/**
 * 
 * @export
 * @interface RRSkills
 */
export interface RRSkills {
    /**
     * 
     * @type {string}
     * @memberof RRSkills
     */
    heading?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRSkills
     */
    items?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RRSocial
 */
export interface RRSocial {
    /**
     * 
     * @type {string}
     * @memberof RRSocial
     */
    handle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRSocial
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRSocial
     */
    name?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RRSortColumns {
    NAME = 'object_name',
    CREATED_DT = 'created_dt'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RRSortDirection {
    ASC = 'asc',
    DESC = 'desc'
}

/**
 * 
 * @export
 * @interface RRUpdateObjectMetadataRequest
 */
export interface RRUpdateObjectMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof RRUpdateObjectMetadataRequest
     */
    object_key: string;
    /**
     * 
     * @type {string}
     * @memberof RRUpdateObjectMetadataRequest
     */
    object_name: string;
    /**
     * 
     * @type {RRObjectType}
     * @memberof RRUpdateObjectMetadataRequest
     */
    object_type: RRObjectType;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRUpdateObjectMetadataRequest
     */
    tags: Array<string>;
}
/**
 * 
 * @export
 * @interface RRUpdateRequest
 */
export interface RRUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof RRUpdateRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof RRUpdateRequest
     */
    object_key: string;
}
/**
 * 
 * @export
 * @interface RRUserPrincipal
 */
export interface RRUserPrincipal {
    /**
     * 
     * @type {string}
     * @memberof RRUserPrincipal
     */
    firebase_id: string;
    /**
     * 
     * @type {string}
     * @memberof RRUserPrincipal
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RRUserPrincipal
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof RRUserPrincipal
     */
    email_verified: boolean;
    /**
     * 
     * @type {string}
     * @memberof RRUserPrincipal
     */
    picture: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof RRUserPrincipal
     */
    roles: { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface RRUserProfile
 */
export interface RRUserProfile {
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    first_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    last_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    location?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    mobile?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    position?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRUserProfile
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface RRWorkExperience
 */
export interface RRWorkExperience {
    /**
     * 
     * @type {string}
     * @memberof RRWorkExperience
     */
    position?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRWorkExperience
     */
    institution?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRWorkExperience
     */
    location?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RRWorkExperience
     */
    is_current?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RRWorkExperience
     */
    items?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RRWorkExperience
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRWorkExperience
     */
    start_date?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RRWorkExperience
     */
    end_date?: string | null;
}

/**
 * CVApi - axios parameter creator
 * @export
 */
export const CVApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make a copy of a CV
         * @summary Make a copy of a CV
         * @param {RRCVKey} rRCVKey Copy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyCV: async (rRCVKey: RRCVKey, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRCVKey' is not null or undefined
            assertParamExists('copyCV', 'rRCVKey', rRCVKey)
            const localVarPath = `/cv/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRCVKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a resume
         * @summary Create a resume
         * @param {RRResume} rRResume Create resume request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResume: async (rRResume: RRResume, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRResume' is not null or undefined
            assertParamExists('createResume', 'rRResume', rRResume)
            const localVarPath = `/cv/create/resume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRResume, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a resume from a template
         * @summary Create a resume
         * @param {RRCreateFromTemplateRequest} rRCreateFromTemplateRequest Create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResumeFromTemplate: async (rRCreateFromTemplateRequest: RRCreateFromTemplateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRCreateFromTemplateRequest' is not null or undefined
            assertParamExists('createResumeFromTemplate', 'rRCreateFromTemplateRequest', rRCreateFromTemplateRequest)
            const localVarPath = `/cv/create/resume/from-template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRCreateFromTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all CVs  by id
         * @param {RRCVByKeyRequest} rRCVByKeyRequest CV Id list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCVMetadataByKey: async (rRCVByKeyRequest: RRCVByKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRCVByKeyRequest' is not null or undefined
            assertParamExists('getAllCVMetadataByKey', 'rRCVByKeyRequest', rRCVByKeyRequest)
            const localVarPath = `/cv/fetch/metadata/byKeyList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRCVByKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all user CVs by type
         * @param {RRPaginatedRequest} rRPaginatedRequest Paginated cv request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPaginatedCVMetadata: async (rRPaginatedRequest: RRPaginatedRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRPaginatedRequest' is not null or undefined
            assertParamExists('getAllPaginatedCVMetadata', 'rRPaginatedRequest', rRPaginatedRequest)
            const localVarPath = `/cv/fetch/metadata/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRPaginatedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CV full data by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCVData: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getCVData', 'key', key)
            const localVarPath = `/cv/fetch/data//byKey/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get demo CV data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemoCvData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cv/fetch/data/demo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CV data
         * @summary Update CV data
         * @param {RRResume} rRResume Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCVData: async (rRResume: RRResume, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRResume' is not null or undefined
            assertParamExists('updateCVData', 'rRResume', rRResume)
            const localVarPath = `/cv/data/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRResume, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CV metadata
         * @summary Update CV metadata
         * @param {RRCVMetadata} rRCVMetadata Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCVMetadata: async (rRCVMetadata: RRCVMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRCVMetadata' is not null or undefined
            assertParamExists('updateCVMetadata', 'rRCVMetadata', rRCVMetadata)
            const localVarPath = `/cv/metadata/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRCVMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CVApi - functional programming interface
 * @export
 */
export const CVApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CVApiAxiosParamCreator(configuration)
    return {
        /**
         * Make a copy of a CV
         * @summary Make a copy of a CV
         * @param {RRCVKey} rRCVKey Copy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyCV(rRCVKey: RRCVKey, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRCVMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyCV(rRCVKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a resume
         * @summary Create a resume
         * @param {RRResume} rRResume Create resume request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResume(rRResume: RRResume, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResume(rRResume, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a resume from a template
         * @summary Create a resume
         * @param {RRCreateFromTemplateRequest} rRCreateFromTemplateRequest Create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResumeFromTemplate(rRCreateFromTemplateRequest: RRCreateFromTemplateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResumeFromTemplate(rRCreateFromTemplateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all CVs  by id
         * @param {RRCVByKeyRequest} rRCVByKeyRequest CV Id list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCVMetadataByKey(rRCVByKeyRequest: RRCVByKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRCVMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCVMetadataByKey(rRCVByKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all user CVs by type
         * @param {RRPaginatedRequest} rRPaginatedRequest Paginated cv request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPaginatedCVMetadata(rRPaginatedRequest: RRPaginatedRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRPaginatedCVResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPaginatedCVMetadata(rRPaginatedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get CV full data by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCVData(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRCVDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCVData(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get demo CV data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDemoCvData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRCVDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDemoCvData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update CV data
         * @summary Update CV data
         * @param {RRResume} rRResume Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCVData(rRResume: RRResume, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCVData(rRResume, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update CV metadata
         * @summary Update CV metadata
         * @param {RRCVMetadata} rRCVMetadata Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCVMetadata(rRCVMetadata: RRCVMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCVMetadata(rRCVMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CVApi - factory interface
 * @export
 */
export const CVApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CVApiFp(configuration)
    return {
        /**
         * Make a copy of a CV
         * @summary Make a copy of a CV
         * @param {RRCVKey} rRCVKey Copy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyCV(rRCVKey: RRCVKey, options?: any): AxiosPromise<RRCVMetadataResponse> {
            return localVarFp.copyCV(rRCVKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a resume
         * @summary Create a resume
         * @param {RRResume} rRResume Create resume request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResume(rRResume: RRResume, options?: any): AxiosPromise<RRKeyResponse> {
            return localVarFp.createResume(rRResume, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a resume from a template
         * @summary Create a resume
         * @param {RRCreateFromTemplateRequest} rRCreateFromTemplateRequest Create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResumeFromTemplate(rRCreateFromTemplateRequest: RRCreateFromTemplateRequest, options?: any): AxiosPromise<RRKeyResponse> {
            return localVarFp.createResumeFromTemplate(rRCreateFromTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all CVs  by id
         * @param {RRCVByKeyRequest} rRCVByKeyRequest CV Id list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCVMetadataByKey(rRCVByKeyRequest: RRCVByKeyRequest, options?: any): AxiosPromise<RRCVMetadataResponse> {
            return localVarFp.getAllCVMetadataByKey(rRCVByKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all user CVs by type
         * @param {RRPaginatedRequest} rRPaginatedRequest Paginated cv request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPaginatedCVMetadata(rRPaginatedRequest: RRPaginatedRequest, options?: any): AxiosPromise<RRPaginatedCVResponse> {
            return localVarFp.getAllPaginatedCVMetadata(rRPaginatedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CV full data by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCVData(key: string, options?: any): AxiosPromise<RRCVDataResponse> {
            return localVarFp.getCVData(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get demo CV data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDemoCvData(options?: any): AxiosPromise<RRCVDataResponse> {
            return localVarFp.getDemoCvData(options).then((request) => request(axios, basePath));
        },
        /**
         * Update CV data
         * @summary Update CV data
         * @param {RRResume} rRResume Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCVData(rRResume: RRResume, options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.updateCVData(rRResume, options).then((request) => request(axios, basePath));
        },
        /**
         * Update CV metadata
         * @summary Update CV metadata
         * @param {RRCVMetadata} rRCVMetadata Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCVMetadata(rRCVMetadata: RRCVMetadata, options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.updateCVMetadata(rRCVMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CVApi - object-oriented interface
 * @export
 * @class CVApi
 * @extends {BaseAPI}
 */
export class CVApi extends BaseAPI {
    /**
     * Make a copy of a CV
     * @summary Make a copy of a CV
     * @param {RRCVKey} rRCVKey Copy request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public copyCV(rRCVKey: RRCVKey, options?: any) {
        return CVApiFp(this.configuration).copyCV(rRCVKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a resume
     * @summary Create a resume
     * @param {RRResume} rRResume Create resume request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public createResume(rRResume: RRResume, options?: any) {
        return CVApiFp(this.configuration).createResume(rRResume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a resume from a template
     * @summary Create a resume
     * @param {RRCreateFromTemplateRequest} rRCreateFromTemplateRequest Create request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public createResumeFromTemplate(rRCreateFromTemplateRequest: RRCreateFromTemplateRequest, options?: any) {
        return CVApiFp(this.configuration).createResumeFromTemplate(rRCreateFromTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all CVs  by id
     * @param {RRCVByKeyRequest} rRCVByKeyRequest CV Id list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public getAllCVMetadataByKey(rRCVByKeyRequest: RRCVByKeyRequest, options?: any) {
        return CVApiFp(this.configuration).getAllCVMetadataByKey(rRCVByKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all user CVs by type
     * @param {RRPaginatedRequest} rRPaginatedRequest Paginated cv request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public getAllPaginatedCVMetadata(rRPaginatedRequest: RRPaginatedRequest, options?: any) {
        return CVApiFp(this.configuration).getAllPaginatedCVMetadata(rRPaginatedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CV full data by key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public getCVData(key: string, options?: any) {
        return CVApiFp(this.configuration).getCVData(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get demo CV data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public getDemoCvData(options?: any) {
        return CVApiFp(this.configuration).getDemoCvData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CV data
     * @summary Update CV data
     * @param {RRResume} rRResume Update metadata request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public updateCVData(rRResume: RRResume, options?: any) {
        return CVApiFp(this.configuration).updateCVData(rRResume, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CV metadata
     * @summary Update CV metadata
     * @param {RRCVMetadata} rRCVMetadata Update metadata request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CVApi
     */
    public updateCVMetadata(rRCVMetadata: RRCVMetadata, options?: any) {
        return CVApiFp(this.configuration).updateCVMetadata(rRCVMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepoObjectApi - axios parameter creator
 * @export
 */
export const RepoObjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make a copy of a Object object
         * @summary Make a copy of a Object object
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Copy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyObject: async (rRObjectByKeyRequest: RRObjectByKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRObjectByKeyRequest' is not null or undefined
            assertParamExists('copyObject', 'rRObjectByKeyRequest', rRObjectByKeyRequest)
            const localVarPath = `/object/copy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRObjectByKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Object object
         * @summary Create a Object object
         * @param {RRCreateObjectRequest} rRCreateObjectRequest Create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObject: async (rRCreateObjectRequest: RRCreateObjectRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRCreateObjectRequest' is not null or undefined
            assertParamExists('createObject', 'rRCreateObjectRequest', rRCreateObjectRequest)
            const localVarPath = `/object/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRCreateObjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete object
         * @summary Delete object
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Delete object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObject: async (rRObjectByKeyRequest: RRObjectByKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRObjectByKeyRequest' is not null or undefined
            assertParamExists('deleteObject', 'rRObjectByKeyRequest', rRObjectByKeyRequest)
            const localVarPath = `/object/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRObjectByKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all object metadata by object id
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Object Id list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllObjectMetadataByKey: async (rRObjectByKeyRequest: RRObjectByKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRObjectByKeyRequest' is not null or undefined
            assertParamExists('getAllObjectMetadataByKey', 'rRObjectByKeyRequest', rRObjectByKeyRequest)
            const localVarPath = `/object/all/byKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRObjectByKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all user objects
         * @param {RRPaginatedRequest} rRPaginatedRequest Paginated object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPaginatedObjectMetadata: async (rRPaginatedRequest: RRPaginatedRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRPaginatedRequest' is not null or undefined
            assertParamExists('getAllPaginatedObjectMetadata', 'rRPaginatedRequest', rRPaginatedRequest)
            const localVarPath = `/object/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRPaginatedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the diff between two objects
         * @param {RRObjectDiffRequest} rRObjectDiffRequest Objects to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiff: async (rRObjectDiffRequest: RRObjectDiffRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRObjectDiffRequest' is not null or undefined
            assertParamExists('getDiff', 'rRObjectDiffRequest', rRObjectDiffRequest)
            const localVarPath = `/object/diff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRObjectDiffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get object by object id
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectData: async (objectKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('getObjectData', 'objectKey', objectKey)
            const localVarPath = `/object/{object_key}`
                .replace(`{${"object_key"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get complete object tree
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectDependencyTree: async (objectKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectKey' is not null or undefined
            assertParamExists('getObjectDependencyTree', 'objectKey', objectKey)
            const localVarPath = `/object/dependency/{object_key}`
                .replace(`{${"object_key"}}`, encodeURIComponent(String(objectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark object as read-only
         * @summary Mark object as read-only
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Lock object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockObject: async (rRObjectByKeyRequest: RRObjectByKeyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRObjectByKeyRequest' is not null or undefined
            assertParamExists('lockObject', 'rRObjectByKeyRequest', rRObjectByKeyRequest)
            const localVarPath = `/object/lock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRObjectByKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update object metadata
         * @summary Update object metadata
         * @param {RRUpdateObjectMetadataRequest} rRUpdateObjectMetadataRequest Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadata: async (rRUpdateObjectMetadataRequest: RRUpdateObjectMetadataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRUpdateObjectMetadataRequest' is not null or undefined
            assertParamExists('updateMetadata', 'rRUpdateObjectMetadataRequest', rRUpdateObjectMetadataRequest)
            const localVarPath = `/object/metadata/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRUpdateObjectMetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update object
         * @summary Update object
         * @param {RRUpdateRequest} rRUpdateRequest Update object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObject: async (rRUpdateRequest: RRUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rRUpdateRequest' is not null or undefined
            assertParamExists('updateObject', 'rRUpdateRequest', rRUpdateRequest)
            const localVarPath = `/object/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rRUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepoObjectApi - functional programming interface
 * @export
 */
export const RepoObjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepoObjectApiAxiosParamCreator(configuration)
    return {
        /**
         * Make a copy of a Object object
         * @summary Make a copy of a Object object
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Copy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRCopyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyObject(rRObjectByKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Object object
         * @summary Create a Object object
         * @param {RRCreateObjectRequest} rRCreateObjectRequest Create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createObject(rRCreateObjectRequest: RRCreateObjectRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObject(rRCreateObjectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete object
         * @summary Delete object
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Delete object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObject(rRObjectByKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all object metadata by object id
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Object Id list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllObjectMetadataByKey(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRObjectMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllObjectMetadataByKey(rRObjectByKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all user objects
         * @param {RRPaginatedRequest} rRPaginatedRequest Paginated object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPaginatedObjectMetadata(rRPaginatedRequest: RRPaginatedRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPaginatedObjectMetadata(rRPaginatedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the diff between two objects
         * @param {RRObjectDiffRequest} rRObjectDiffRequest Objects to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiff(rRObjectDiffRequest: RRObjectDiffRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRDiffResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiff(rRObjectDiffRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get object by object id
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectData(objectKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRObjectDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectData(objectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get complete object tree
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectDependencyTree(objectKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRObjectMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectDependencyTree(objectKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark object as read-only
         * @summary Mark object as read-only
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Lock object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockObject(rRObjectByKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update object metadata
         * @summary Update object metadata
         * @param {RRUpdateObjectMetadataRequest} rRUpdateObjectMetadataRequest Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetadata(rRUpdateObjectMetadataRequest: RRUpdateObjectMetadataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetadata(rRUpdateObjectMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update object
         * @summary Update object
         * @param {RRUpdateRequest} rRUpdateRequest Update object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateObject(rRUpdateRequest: RRUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateObject(rRUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepoObjectApi - factory interface
 * @export
 */
export const RepoObjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepoObjectApiFp(configuration)
    return {
        /**
         * Make a copy of a Object object
         * @summary Make a copy of a Object object
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Copy request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): AxiosPromise<RRCopyResponse> {
            return localVarFp.copyObject(rRObjectByKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Object object
         * @summary Create a Object object
         * @param {RRCreateObjectRequest} rRCreateObjectRequest Create request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObject(rRCreateObjectRequest: RRCreateObjectRequest, options?: any): AxiosPromise<RRKeyResponse> {
            return localVarFp.createObject(rRCreateObjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete object
         * @summary Delete object
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Delete object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.deleteObject(rRObjectByKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all object metadata by object id
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Object Id list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllObjectMetadataByKey(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): AxiosPromise<RRObjectMetadataResponse> {
            return localVarFp.getAllObjectMetadataByKey(rRObjectByKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all user objects
         * @param {RRPaginatedRequest} rRPaginatedRequest Paginated object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPaginatedObjectMetadata(rRPaginatedRequest: RRPaginatedRequest, options?: any): AxiosPromise<RRPaginatedResponse> {
            return localVarFp.getAllPaginatedObjectMetadata(rRPaginatedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the diff between two objects
         * @param {RRObjectDiffRequest} rRObjectDiffRequest Objects to compare
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiff(rRObjectDiffRequest: RRObjectDiffRequest, options?: any): AxiosPromise<RRDiffResponse> {
            return localVarFp.getDiff(rRObjectDiffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get object by object id
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectData(objectKey: string, options?: any): AxiosPromise<RRObjectDataResponse> {
            return localVarFp.getObjectData(objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get complete object tree
         * @param {string} objectKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectDependencyTree(objectKey: string, options?: any): AxiosPromise<RRObjectMetadataResponse> {
            return localVarFp.getObjectDependencyTree(objectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark object as read-only
         * @summary Mark object as read-only
         * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Lock object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.lockObject(rRObjectByKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update object metadata
         * @summary Update object metadata
         * @param {RRUpdateObjectMetadataRequest} rRUpdateObjectMetadataRequest Update metadata request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadata(rRUpdateObjectMetadataRequest: RRUpdateObjectMetadataRequest, options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.updateMetadata(rRUpdateObjectMetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update object
         * @summary Update object
         * @param {RRUpdateRequest} rRUpdateRequest Update object request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObject(rRUpdateRequest: RRUpdateRequest, options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.updateObject(rRUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepoObjectApi - object-oriented interface
 * @export
 * @class RepoObjectApi
 * @extends {BaseAPI}
 */
export class RepoObjectApi extends BaseAPI {
    /**
     * Make a copy of a Object object
     * @summary Make a copy of a Object object
     * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Copy request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public copyObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).copyObject(rRObjectByKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Object object
     * @summary Create a Object object
     * @param {RRCreateObjectRequest} rRCreateObjectRequest Create request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public createObject(rRCreateObjectRequest: RRCreateObjectRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).createObject(rRCreateObjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete object
     * @summary Delete object
     * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Delete object request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public deleteObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).deleteObject(rRObjectByKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all object metadata by object id
     * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Object Id list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public getAllObjectMetadataByKey(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).getAllObjectMetadataByKey(rRObjectByKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all user objects
     * @param {RRPaginatedRequest} rRPaginatedRequest Paginated object request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public getAllPaginatedObjectMetadata(rRPaginatedRequest: RRPaginatedRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).getAllPaginatedObjectMetadata(rRPaginatedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the diff between two objects
     * @param {RRObjectDiffRequest} rRObjectDiffRequest Objects to compare
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public getDiff(rRObjectDiffRequest: RRObjectDiffRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).getDiff(rRObjectDiffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get object by object id
     * @param {string} objectKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public getObjectData(objectKey: string, options?: any) {
        return RepoObjectApiFp(this.configuration).getObjectData(objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get complete object tree
     * @param {string} objectKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public getObjectDependencyTree(objectKey: string, options?: any) {
        return RepoObjectApiFp(this.configuration).getObjectDependencyTree(objectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark object as read-only
     * @summary Mark object as read-only
     * @param {RRObjectByKeyRequest} rRObjectByKeyRequest Lock object request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public lockObject(rRObjectByKeyRequest: RRObjectByKeyRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).lockObject(rRObjectByKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update object metadata
     * @summary Update object metadata
     * @param {RRUpdateObjectMetadataRequest} rRUpdateObjectMetadataRequest Update metadata request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public updateMetadata(rRUpdateObjectMetadataRequest: RRUpdateObjectMetadataRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).updateMetadata(rRUpdateObjectMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update object
     * @summary Update object
     * @param {RRUpdateRequest} rRUpdateRequest Update object request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoObjectApi
     */
    public updateObject(rRUpdateRequest: RRUpdateRequest, options?: any) {
        return RepoObjectApiFp(this.configuration).updateObject(rRUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a user
         * @summary Create a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a user
         * @summary Create a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RRGenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Create a user
         * @summary Create a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(options?: any): AxiosPromise<RRGenericResponse> {
            return localVarFp.createUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Create a user
     * @summary Create a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(options?: any) {
        return UserApiFp(this.configuration).createUser(options).then((request) => request(this.axios, this.basePath));
    }
}


